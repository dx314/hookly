// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: webhooks.sql

package db

import (
	"context"
	"database/sql"
)

const countWebhooks = `-- name: CountWebhooks :one
SELECT COUNT(*) FROM webhooks
WHERE (?1 IS NULL OR endpoint_id = ?1)
  AND (?2 IS NULL OR status = ?2)
`

type CountWebhooksParams struct {
	EndpointID interface{} `json:"endpoint_id"`
	Status     interface{} `json:"status"`
}

func (q *Queries) CountWebhooks(ctx context.Context, arg CountWebhooksParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWebhooks, arg.EndpointID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhooks (id, endpoint_id, received_at, headers, payload, signature_valid, status, attempts)
VALUES (?, ?, datetime('now'), ?, ?, ?, 'pending', 0)
RETURNING id, endpoint_id, received_at, headers, payload, signature_valid, status, attempts, last_attempt_at, delivered_at, error_message, notification_sent
`

type CreateWebhookParams struct {
	ID             string `json:"id"`
	EndpointID     string `json:"endpoint_id"`
	Headers        string `json:"headers"`
	Payload        []byte `json:"payload"`
	SignatureValid int64  `json:"signature_valid"`
}

func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, createWebhook,
		arg.ID,
		arg.EndpointID,
		arg.Headers,
		arg.Payload,
		arg.SignatureValid,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.ReceivedAt,
		&i.Headers,
		&i.Payload,
		&i.SignatureValid,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.DeliveredAt,
		&i.ErrorMessage,
		&i.NotificationSent,
	)
	return i, err
}

const deleteDeadLetterWebhooks = `-- name: DeleteDeadLetterWebhooks :execrows
DELETE FROM webhooks
WHERE status = 'dead_letter'
  AND received_at < datetime('now', '-14 days')
`

// Delete dead letter webhooks older than 14 days from receipt.
func (q *Queries) DeleteDeadLetterWebhooks(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteDeadLetterWebhooks)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteDeliveredWebhooks = `-- name: DeleteDeliveredWebhooks :execrows
DELETE FROM webhooks
WHERE status = 'delivered'
  AND delivered_at < datetime('now', '-7 days')
`

// Delete delivered webhooks older than 7 days.
func (q *Queries) DeleteDeliveredWebhooks(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteDeliveredWebhooks)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteFailedWebhooks = `-- name: DeleteFailedWebhooks :execrows
DELETE FROM webhooks
WHERE status = 'failed'
  AND last_attempt_at < datetime('now', '-7 days')
`

// Delete failed webhooks older than 7 days from last attempt.
func (q *Queries) DeleteFailedWebhooks(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteFailedWebhooks)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getDeadLetterWebhooks = `-- name: GetDeadLetterWebhooks :many
SELECT w.id, w.endpoint_id, w.received_at, w.headers, w.payload, w.signature_valid, w.status, w.attempts, w.last_attempt_at, w.delivered_at, w.error_message, w.notification_sent, e.name as endpoint_name, e.destination_url, e.provider_type
FROM webhooks w
JOIN endpoints e ON w.endpoint_id = e.id
WHERE w.status = 'dead_letter'
ORDER BY w.received_at DESC
LIMIT ?
`

type GetDeadLetterWebhooksRow struct {
	ID               string         `json:"id"`
	EndpointID       string         `json:"endpoint_id"`
	ReceivedAt       string         `json:"received_at"`
	Headers          string         `json:"headers"`
	Payload          []byte         `json:"payload"`
	SignatureValid   int64          `json:"signature_valid"`
	Status           string         `json:"status"`
	Attempts         int64          `json:"attempts"`
	LastAttemptAt    sql.NullString `json:"last_attempt_at"`
	DeliveredAt      sql.NullString `json:"delivered_at"`
	ErrorMessage     sql.NullString `json:"error_message"`
	NotificationSent int64          `json:"notification_sent"`
	EndpointName     string         `json:"endpoint_name"`
	DestinationUrl   string         `json:"destination_url"`
	ProviderType     string         `json:"provider_type"`
}

// Get recently dead-lettered webhooks for notification.
func (q *Queries) GetDeadLetterWebhooks(ctx context.Context, limit int64) ([]GetDeadLetterWebhooksRow, error) {
	rows, err := q.db.QueryContext(ctx, getDeadLetterWebhooks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDeadLetterWebhooksRow{}
	for rows.Next() {
		var i GetDeadLetterWebhooksRow
		if err := rows.Scan(
			&i.ID,
			&i.EndpointID,
			&i.ReceivedAt,
			&i.Headers,
			&i.Payload,
			&i.SignatureValid,
			&i.Status,
			&i.Attempts,
			&i.LastAttemptAt,
			&i.DeliveredAt,
			&i.ErrorMessage,
			&i.NotificationSent,
			&i.EndpointName,
			&i.DestinationUrl,
			&i.ProviderType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingWebhooks = `-- name: GetPendingWebhooks :many
SELECT w.id, w.endpoint_id, w.received_at, w.headers, w.payload, w.signature_valid, w.status, w.attempts, w.last_attempt_at, w.delivered_at, w.error_message, w.notification_sent, e.destination_url, e.provider_type
FROM webhooks w
JOIN endpoints e ON w.endpoint_id = e.id
WHERE w.status = 'pending'
  AND e.muted = 0
  -- Respect backoff: either never attempted, or backoff delay has passed
  AND (
    w.last_attempt_at IS NULL
    OR datetime(w.last_attempt_at, '+' || MIN(1 << w.attempts, 3600) || ' seconds') <= datetime('now')
  )
  -- In-order delivery: only the oldest pending webhook per endpoint
  AND w.received_at = (
    SELECT MIN(w2.received_at)
    FROM webhooks w2
    WHERE w2.endpoint_id = w.endpoint_id
      AND w2.status = 'pending'
  )
ORDER BY w.received_at ASC
LIMIT ?
`

type GetPendingWebhooksRow struct {
	ID               string         `json:"id"`
	EndpointID       string         `json:"endpoint_id"`
	ReceivedAt       string         `json:"received_at"`
	Headers          string         `json:"headers"`
	Payload          []byte         `json:"payload"`
	SignatureValid   int64          `json:"signature_valid"`
	Status           string         `json:"status"`
	Attempts         int64          `json:"attempts"`
	LastAttemptAt    sql.NullString `json:"last_attempt_at"`
	DeliveredAt      sql.NullString `json:"delivered_at"`
	ErrorMessage     sql.NullString `json:"error_message"`
	NotificationSent int64          `json:"notification_sent"`
	DestinationUrl   string         `json:"destination_url"`
	ProviderType     string         `json:"provider_type"`
}

// Get webhooks ready for delivery with backoff timing and in-order per endpoint.
// Only returns the oldest pending webhook per endpoint that has passed its backoff delay.
func (q *Queries) GetPendingWebhooks(ctx context.Context, limit int64) ([]GetPendingWebhooksRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingWebhooks, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingWebhooksRow{}
	for rows.Next() {
		var i GetPendingWebhooksRow
		if err := rows.Scan(
			&i.ID,
			&i.EndpointID,
			&i.ReceivedAt,
			&i.Headers,
			&i.Payload,
			&i.SignatureValid,
			&i.Status,
			&i.Attempts,
			&i.LastAttemptAt,
			&i.DeliveredAt,
			&i.ErrorMessage,
			&i.NotificationSent,
			&i.DestinationUrl,
			&i.ProviderType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueueStats = `-- name: GetQueueStats :one
SELECT
    SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) AS pending_count,
    SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) AS failed_count,
    SUM(CASE WHEN status = 'dead_letter' THEN 1 ELSE 0 END) AS dead_letter_count
FROM webhooks
`

type GetQueueStatsRow struct {
	PendingCount    sql.NullFloat64 `json:"pending_count"`
	FailedCount     sql.NullFloat64 `json:"failed_count"`
	DeadLetterCount sql.NullFloat64 `json:"dead_letter_count"`
}

func (q *Queries) GetQueueStats(ctx context.Context) (GetQueueStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getQueueStats)
	var i GetQueueStatsRow
	err := row.Scan(&i.PendingCount, &i.FailedCount, &i.DeadLetterCount)
	return i, err
}

const getUnnotifiedDeadLetters = `-- name: GetUnnotifiedDeadLetters :many
SELECT w.id, w.endpoint_id, w.received_at, w.headers, w.payload, w.signature_valid, w.status, w.attempts, w.last_attempt_at, w.delivered_at, w.error_message, w.notification_sent, e.name as endpoint_name, e.destination_url as endpoint_destination_url
FROM webhooks w
JOIN endpoints e ON w.endpoint_id = e.id
WHERE w.status = 'dead_letter'
  AND w.notification_sent = 0
ORDER BY w.received_at DESC
LIMIT ?
`

type GetUnnotifiedDeadLettersRow struct {
	ID                     string         `json:"id"`
	EndpointID             string         `json:"endpoint_id"`
	ReceivedAt             string         `json:"received_at"`
	Headers                string         `json:"headers"`
	Payload                []byte         `json:"payload"`
	SignatureValid         int64          `json:"signature_valid"`
	Status                 string         `json:"status"`
	Attempts               int64          `json:"attempts"`
	LastAttemptAt          sql.NullString `json:"last_attempt_at"`
	DeliveredAt            sql.NullString `json:"delivered_at"`
	ErrorMessage           sql.NullString `json:"error_message"`
	NotificationSent       int64          `json:"notification_sent"`
	EndpointName           string         `json:"endpoint_name"`
	EndpointDestinationUrl string         `json:"endpoint_destination_url"`
}

// Get dead letter webhooks that haven't been notified yet.
func (q *Queries) GetUnnotifiedDeadLetters(ctx context.Context, limit int64) ([]GetUnnotifiedDeadLettersRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnnotifiedDeadLetters, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnnotifiedDeadLettersRow{}
	for rows.Next() {
		var i GetUnnotifiedDeadLettersRow
		if err := rows.Scan(
			&i.ID,
			&i.EndpointID,
			&i.ReceivedAt,
			&i.Headers,
			&i.Payload,
			&i.SignatureValid,
			&i.Status,
			&i.Attempts,
			&i.LastAttemptAt,
			&i.DeliveredAt,
			&i.ErrorMessage,
			&i.NotificationSent,
			&i.EndpointName,
			&i.EndpointDestinationUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhook = `-- name: GetWebhook :one
SELECT id, endpoint_id, received_at, headers, payload, signature_valid, status, attempts, last_attempt_at, delivered_at, error_message, notification_sent FROM webhooks WHERE id = ?
`

func (q *Queries) GetWebhook(ctx context.Context, id string) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, getWebhook, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.ReceivedAt,
		&i.Headers,
		&i.Payload,
		&i.SignatureValid,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.DeliveredAt,
		&i.ErrorMessage,
		&i.NotificationSent,
	)
	return i, err
}

const getWebhookWithEndpoint = `-- name: GetWebhookWithEndpoint :one
SELECT w.id, w.endpoint_id, w.received_at, w.headers, w.payload, w.signature_valid, w.status, w.attempts, w.last_attempt_at, w.delivered_at, w.error_message, w.notification_sent, e.name as endpoint_name, e.destination_url as endpoint_destination_url
FROM webhooks w
JOIN endpoints e ON w.endpoint_id = e.id
WHERE w.id = ?
`

type GetWebhookWithEndpointRow struct {
	ID                     string         `json:"id"`
	EndpointID             string         `json:"endpoint_id"`
	ReceivedAt             string         `json:"received_at"`
	Headers                string         `json:"headers"`
	Payload                []byte         `json:"payload"`
	SignatureValid         int64          `json:"signature_valid"`
	Status                 string         `json:"status"`
	Attempts               int64          `json:"attempts"`
	LastAttemptAt          sql.NullString `json:"last_attempt_at"`
	DeliveredAt            sql.NullString `json:"delivered_at"`
	ErrorMessage           sql.NullString `json:"error_message"`
	NotificationSent       int64          `json:"notification_sent"`
	EndpointName           string         `json:"endpoint_name"`
	EndpointDestinationUrl string         `json:"endpoint_destination_url"`
}

// Get webhook with endpoint info for notifications.
func (q *Queries) GetWebhookWithEndpoint(ctx context.Context, id string) (GetWebhookWithEndpointRow, error) {
	row := q.db.QueryRowContext(ctx, getWebhookWithEndpoint, id)
	var i GetWebhookWithEndpointRow
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.ReceivedAt,
		&i.Headers,
		&i.Payload,
		&i.SignatureValid,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.DeliveredAt,
		&i.ErrorMessage,
		&i.NotificationSent,
		&i.EndpointName,
		&i.EndpointDestinationUrl,
	)
	return i, err
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT id, endpoint_id, received_at, headers, payload, signature_valid, status, attempts, last_attempt_at, delivered_at, error_message, notification_sent FROM webhooks
WHERE (?3 IS NULL OR endpoint_id = ?3)
  AND (?4 IS NULL OR status = ?4)
ORDER BY received_at DESC
LIMIT ? OFFSET ?
`

type ListWebhooksParams struct {
	EndpointID interface{} `json:"endpoint_id"`
	Status     interface{} `json:"status"`
	Limit      int64       `json:"limit"`
	Offset     int64       `json:"offset"`
}

func (q *Queries) ListWebhooks(ctx context.Context, arg ListWebhooksParams) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooks,
		arg.EndpointID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.EndpointID,
			&i.ReceivedAt,
			&i.Headers,
			&i.Payload,
			&i.SignatureValid,
			&i.Status,
			&i.Attempts,
			&i.LastAttemptAt,
			&i.DeliveredAt,
			&i.ErrorMessage,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDeadLetter = `-- name: MarkDeadLetter :execrows
UPDATE webhooks
SET status = 'dead_letter'
WHERE status = 'pending'
  AND received_at < datetime('now', '-7 days')
`

// Mark pending webhooks as dead_letter after 7 days.
func (q *Queries) MarkDeadLetter(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, markDeadLetter)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const markNotificationSent = `-- name: MarkNotificationSent :exec
UPDATE webhooks
SET notification_sent = 1
WHERE id = ?
`

// Mark notification as sent to prevent spam.
func (q *Queries) MarkNotificationSent(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markNotificationSent, id)
	return err
}

const markWebhookDelivered = `-- name: MarkWebhookDelivered :one
UPDATE webhooks
SET status = 'delivered',
    attempts = attempts + 1,
    last_attempt_at = datetime('now'),
    delivered_at = datetime('now'),
    error_message = NULL
WHERE id = ?
RETURNING id, endpoint_id, received_at, headers, payload, signature_valid, status, attempts, last_attempt_at, delivered_at, error_message, notification_sent
`

// Mark a webhook as successfully delivered.
func (q *Queries) MarkWebhookDelivered(ctx context.Context, id string) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, markWebhookDelivered, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.ReceivedAt,
		&i.Headers,
		&i.Payload,
		&i.SignatureValid,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.DeliveredAt,
		&i.ErrorMessage,
		&i.NotificationSent,
	)
	return i, err
}

const markWebhookFailed = `-- name: MarkWebhookFailed :one
UPDATE webhooks
SET status = 'failed',
    attempts = attempts + 1,
    last_attempt_at = datetime('now'),
    error_message = ?
WHERE id = ?
RETURNING id, endpoint_id, received_at, headers, payload, signature_valid, status, attempts, last_attempt_at, delivered_at, error_message, notification_sent
`

type MarkWebhookFailedParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	ID           string         `json:"id"`
}

// Mark a webhook as permanently failed (4xx response).
func (q *Queries) MarkWebhookFailed(ctx context.Context, arg MarkWebhookFailedParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, markWebhookFailed, arg.ErrorMessage, arg.ID)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.ReceivedAt,
		&i.Headers,
		&i.Payload,
		&i.SignatureValid,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.DeliveredAt,
		&i.ErrorMessage,
		&i.NotificationSent,
	)
	return i, err
}

const recordWebhookAttempt = `-- name: RecordWebhookAttempt :one
UPDATE webhooks
SET attempts = attempts + 1,
    last_attempt_at = datetime('now'),
    error_message = ?
WHERE id = ?
RETURNING id, endpoint_id, received_at, headers, payload, signature_valid, status, attempts, last_attempt_at, delivered_at, error_message, notification_sent
`

type RecordWebhookAttemptParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	ID           string         `json:"id"`
}

// Record a failed delivery attempt (5xx or network error) - stays pending for retry.
func (q *Queries) RecordWebhookAttempt(ctx context.Context, arg RecordWebhookAttemptParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, recordWebhookAttempt, arg.ErrorMessage, arg.ID)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.ReceivedAt,
		&i.Headers,
		&i.Payload,
		&i.SignatureValid,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.DeliveredAt,
		&i.ErrorMessage,
		&i.NotificationSent,
	)
	return i, err
}

const resetWebhookForReplay = `-- name: ResetWebhookForReplay :one
UPDATE webhooks
SET status = 'pending',
    attempts = 0,
    last_attempt_at = NULL,
    delivered_at = NULL,
    error_message = NULL,
    notification_sent = 0
WHERE id = ?
RETURNING id, endpoint_id, received_at, headers, payload, signature_valid, status, attempts, last_attempt_at, delivered_at, error_message, notification_sent
`

func (q *Queries) ResetWebhookForReplay(ctx context.Context, id string) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, resetWebhookForReplay, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.EndpointID,
		&i.ReceivedAt,
		&i.Headers,
		&i.Payload,
		&i.SignatureValid,
		&i.Status,
		&i.Attempts,
		&i.LastAttemptAt,
		&i.DeliveredAt,
		&i.ErrorMessage,
		&i.NotificationSent,
	)
	return i, err
}
